#ifndef CSSATREE_H
#define CSSATREE_H


#include "intermediate/intermediateCode.h"
#include "util/types.h"
#include "vm/value.h"
#include "util/debug.h"

#include "ranges.h"
#include "cat_stack.h"

#include <optional>

namespace {
using Instr = ngpl::intermediate::IntermediateInstruction;
ADD_PTR_TYPES(Instr);
}


namespace ngpl::CSSA {

PTRS_FOR_STRUCT(ValueStore);
PTRS_FOR_STRUCT(TaggedInstruction);
PTRS_FOR_STRUCT(TaggedValue);

struct TaggedValue {
	int64_t id;
	std::optional<Value> constValue;

	TaggedInstructionWeakPtr generatedBy;
	int64_t lamportTimestamp;
	int32_t usageCount = 0;
	bool isAtFinalLocation = false;
	bool isVirtual = false;
	//cat::OwningPtr<std::unordered_map<TaggedValueWeakPtr, int32_t>> recursiveArguments = nullptr;
protected:
	friend struct ValueStore;
	TaggedValue(
			int64_t id,
			std::optional<Value>&& constValue,
			TaggedInstructionWeakPtr generatedBy,
			int64_t lamportTimestamp,
			int16_t usageCount = 0,
			bool isAtFinalLocation = false,
			bool isVirtual = false
	)
		: id(id),
		  constValue(std::move(constValue)),
		  generatedBy(generatedBy),
		  lamportTimestamp(lamportTimestamp),
		  usageCount(usageCount),
		  isAtFinalLocation(isAtFinalLocation),
		  isVirtual(isVirtual)
	{}
/*
	TaggedValue(
			int64_t id,
			std::optional<Value>&& constValue,
			TaggedInstructionPtr&& generatedBy,
			int64_t lamportTimestamp,
			int16_t usageCount = 0,
			bool isAtFinalLocation = false
	)
		: id(id),
		  constValue(std::move(constValue)),
		  generatedBy(std::move(generatedBy)),
		  lamportTimestamp(lamportTimestamp),
		  usageCount(usageCount),
		  isAtFinalLocation(isAtFinalLocation)
	{}
*/
};

cat::WriterObjectABC& operator += (cat::WriterObjectABC& s, const TaggedValue& v);

struct OperandUsege { // TODO: find beter name for struct OperandUsege
	TaggedValueWeakPtr val;
	bool usedByMultipleOperands;
	int32_t usageCount;
};

struct InstructionUsege { // TODO: find beter name for struct OperandUsege
	TaggedInstructionWeakPtr instr;
	bool usedByMultipleOperands;
	int32_t usageCount;
};

struct RequirementStats {
	// this could be an unordered_set, but we need the order here...:
	std::vector<OperandUsege> values;
	// this could be an unordered_set, but we need the order here...:
	std::vector<InstructionUsege> instructions;

};

enum class TaggedInstrKind{
	SIMPLE_INSTR,
	IF_ELSE,
	__
};

struct TaggedInstruction {
	int64_t id;
	TaggedInstrKind kind;
	InstrPtr instr;
	std::vector<TaggedValueWeakPtr> operands; // ie. the arguments to a function or the condition in an if statement
	std::vector<std::vector<TaggedValueWeakPtr>> branches; // the values generated by each branch (before the Phi function)
	std::vector<TaggedValueWeakPtr> generatesValues;	// the resulting values (after the Phi function)
	TaggedValueWeakPtr causesSideEffect = nullptr;
	int64_t lamportTimestamp;
	// this could be an opional, but Qt's debugger doesn't like them :'(
	cat::OwningPtr<RequirementStats> recursiveRequirements = nullptr;
	//TaggedValueWeakPtr result = nullptr;

	void addBranch(std::vector<TaggedValueWeakPtr>&& branch) {
		NGPL_ASSERT(branch.size() == generatesValues.size());
		branches.push_back(std::move(branch));
		int64_t brachLamportTimestamp = 0;
		foreach_n(arg, this->branches.back()) {
			brachLamportTimestamp = std::max(arg->lamportTimestamp, brachLamportTimestamp);
			arg->usageCount += 1;
		}
		brachLamportTimestamp += 1;
		lamportTimestamp = std::max(lamportTimestamp, brachLamportTimestamp);
	}

protected:
	friend struct ValueStore;

	TaggedInstruction(int64_t id, TaggedInstrKind kind, InstrPtr&& instr, std::vector<TaggedValueWeakPtr>&& arguments)
		: id(id),
		  kind(kind),
		  instr(std::move(instr)),
		  operands(std::move(arguments))
	{
		lamportTimestamp = 0;
		foreach_n(arg, this->operands) {
			lamportTimestamp = std::max(arg->lamportTimestamp, lamportTimestamp);
			arg->usageCount += 1;
		}
		lamportTimestamp += 1;
	}
};

cat::WriterObjectABC& operator += (cat::WriterObjectABC& s, const TaggedInstruction& v);

struct ValueStore {
protected:
	int64_t _nextValueId = 1;
	int64_t _nextInstrId = -1;
	int64_t _nextScenarioId = -1;
	std::vector<TaggedValuePtr> _allValues{};
	//std::vector<TaggedCellPtr> _allCells{};
	std::vector<TaggedInstructionPtr> _allInstructions{};

public:
	TaggedValueWeakPtr getNewValue(std::optional<Value>&& constValue, TaggedInstructionWeakPtr generatedBy, bool isVirtual = false) {
		auto lamportTimestamp = generatedBy ? generatedBy->lamportTimestamp : 0;
		auto* taggedValuePtr = new TaggedValue{_nextValueId++, std::move(constValue), generatedBy, lamportTimestamp, 0, false, isVirtual};
//		if (taggedValuePtr->generatedBy) {
//			taggedValuePtr->generatedBy->result = taggedValuePtr;
//		}
		auto result = _allValues.emplace_back(taggedValuePtr).weak();

		if (not result->isVirtual and result->generatedBy != nullptr) {
			generatedBy->generatesValues.push_back(result);
		}

		return result;
	}
/*
	TaggedCellWeakPtr getNewCell(TaggedValueWeakPtr value = nullptr) {
		if (value != nullptr) {
			value = getNewValue();
		}
		auto* taggedCellPtr = new TaggedCell{_nextCellId--, value};
		return _allCells.emplace_back(taggedCellPtr).weak();;
	}
*/
	TaggedInstructionWeakPtr getNewInstruction(TaggedInstrKind kind, InstrPtr&& instr, std::vector<TaggedValueWeakPtr>&& arguments) {
		TaggedInstructionPtr taggedInstr = new TaggedInstruction(_nextInstrId++, kind,  std::move(instr), std::move(arguments));
		TaggedInstructionWeakPtr result = taggedInstr.weak();
		_allInstructions.push_back(std::move(taggedInstr));
		return result;
	}

	int64_t getNewScenarioId() {
		return _nextScenarioId++;
	}

};

struct StackLayoutScenario {
public:
	StackLayoutScenario(ValueStoreWeakPtr&& valueStore)
		: _valueStore(valueStore)
	{
		_id = _valueStore->getNewScenarioId();
	}

	StackLayoutScenario(StackLayoutScenario&&) = default;
	StackLayoutScenario& operator =(StackLayoutScenario&&) = default;

private:
	StackLayoutScenario(const StackLayoutScenario&) = default;
	StackLayoutScenario& operator =(const StackLayoutScenario&) = default;

public:
	StackLayoutScenario newScenarioFromThis() {
		StackLayoutScenario newScenario(*this);
		newScenario._id = newScenario._valueStore->getNewScenarioId();
		return newScenario;
	}

protected:
	int64_t _id;
	ValueStoreWeakPtr _valueStore;
	cat::Stack<TaggedValueWeakPtr> _stack{};
	std::vector<TaggedValueWeakPtr> _instructionsWithSideEffect;
	uint32_t _stackCompressionBarrier = 0; // the _stack must NOT be compressed below this address!
	bool _isValid = true;
public:

	void invalidate(){ _isValid = false; }
	bool isValid() const { return _isValid; }
	int64_t id() const { return _id; }

	/**
	 * @brief The stack must NOT be compressed below this (absolute) address!
	 * @return
	 */
	uint32_t stackCompressionBarrier() const { return _stackCompressionBarrier; }
	void setStackCompressionBarrier(uint32_t v) { _stackCompressionBarrier = v;	}

	void pushValue(std::optional<Value>&& constValue, TaggedInstructionWeakPtr generatedBy) {
		_stack.push(_valueStore->getNewValue(std::move(constValue), generatedBy));
	}

	void pushExistingValue(TaggedValueWeakPtr value) {
		_stack.push(value);
	}

	TaggedValueWeakPtr popValue() {
		return _stack.pop();
	}

	TaggedValueWeakPtr peekValue() {
		return _stack.peek();
	}

	void readValue(StackAddr addr) {
		_stack.push(at(addr));
	}

	void writeValue(StackAddr addr) {
		at(addr) = _stack.pop();
	}

	void setValue(StackAddr addr, TaggedValueWeakPtr value) {
		at(addr) = value;
	}

	TaggedValueWeakPtr getValue(StackAddr addr) {
		return at(addr);
	}

	void swap() {
		std::swap(at(0_sa), at(1_sa));
	}


	void retagStackValues() {
		invalidate();
		const auto stackSize = _stack.size();
		//_stack.clear();
		for (auto i = stackSize; i-->0;) {
			_stack.at(i) = _valueStore->getNewValue(std::nullopt, nullptr);
		}
	}

protected:
	TaggedInstructionWeakPtr addInstruction(TaggedInstrKind kind, InstrPtr&& instr, std::vector<TaggedValueWeakPtr>&& arguments) {
		return _valueStore->getNewInstruction(kind, std::move(instr), std::move(arguments));
	}

	TaggedInstructionWeakPtr addInstructionWithSideEffect(TaggedInstrKind kind, InstrPtr&& instr, std::vector<TaggedValueWeakPtr>&& arguments) {
		if (not _instructionsWithSideEffect.empty()) {
			arguments.push_back(_instructionsWithSideEffect.back());
		}
		auto taggedInstr = addInstruction(kind, std::move(instr), std::move(arguments));
		taggedInstr->causesSideEffect =_valueStore->getNewValue(std::nullopt, taggedInstr, true);
		_instructionsWithSideEffect.push_back(taggedInstr->causesSideEffect);
		return taggedInstr;
	}

public:
	TaggedInstructionWeakPtr addSimpleInstr(InstrPtr&& instr, std::vector<TaggedValueWeakPtr>&& arguments) {
		return addInstruction(TaggedInstrKind::SIMPLE_INSTR, std::move(instr), std::move(arguments));
	}

	TaggedInstructionWeakPtr addSimpleInstrWithSideEffect(InstrPtr&& instr, std::vector<TaggedValueWeakPtr>&& arguments) {
		return addInstructionWithSideEffect(TaggedInstrKind::SIMPLE_INSTR, std::move(instr), std::move(arguments));
	}

	TaggedInstructionWeakPtr addIfInstr(InstrPtr&& instr, std::vector<TaggedValueWeakPtr>&& arguments) {
		return addInstruction(TaggedInstrKind::IF_ELSE, std::move(instr), std::move(arguments));
	}

	TaggedInstructionWeakPtr addIfInstrWithSideEffect(InstrPtr&& instr, std::vector<TaggedValueWeakPtr>&& arguments) {
		return addInstructionWithSideEffect(TaggedInstrKind::IF_ELSE, std::move(instr), std::move(arguments));
	}

	void addExistingSideEffect(TaggedValueWeakPtr value) {
		//NGPL_ASSERT(value->generatedBy->);
		_instructionsWithSideEffect.push_back(value);
	}

	bool sideEffectHasHappened(TaggedValueCWeakPtr value) const {
		NGPL_ASSERT(value->isVirtual);
		return not getAllInstructionsWithSideEffect().empty() and getAllInstructionsWithSideEffect().back()->id == value->id;
	}

	cat::Stack<TaggedValueWeakPtr>& getStack() { return _stack; }
	const cat::Stack<TaggedValueWeakPtr>& getStack() const { return _stack; }
	Address stackSize() const { return Address(_stack.size()); }

	inline const TaggedValueWeakPtr& at(StackAddr a) const { return at(getAbsoluteAddress(a)); }
	inline TaggedValueWeakPtr& at(StackAddr a) { return at(getAbsoluteAddress(a)); }

	inline const TaggedValueWeakPtr& at(FrameAddr a) const { return _stack.at(Address(a)); }
	inline TaggedValueWeakPtr& at(FrameAddr a) { return _stack.at(Address(a)); }

	const std::vector<TaggedValueWeakPtr>& getAllInstructionsWithSideEffect() const { return _instructionsWithSideEffect; }

	FrameAddr getAbsoluteAddress(StackAddr a) const {
		return  FrameAddr(currentStackTop() - Address(a));
	}
	StackAddr getRelativeAddress(FrameAddr a) const {
		return  StackAddr(currentStackTop() - a);
	}
	FrameAddr currentStackTop() const {
		return FrameAddr(stackSize()) - 1;
	}


};

struct StackLayoutScenarioHash
{
	std::size_t operator()(StackLayoutScenario const& s) const noexcept{
		return s.id();
	}
};

struct StackLayoutScenarioEqualTo
{
	std::size_t operator()(StackLayoutScenario const& lhs, StackLayoutScenario const& rhs) const noexcept{
		return lhs.id() == rhs.id();
	}
};

struct IntermediateCode {
	std::vector<InstrPtr> vector;

	void push_back(InstrPtr&& instr) {
		vector.push_back(std::move(instr));
	}

};







class CSSATree
{
public:
	CSSATree();
};

}

#endif // CSSATREE_H
